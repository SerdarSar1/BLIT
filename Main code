import pygame as pg
import random as r
import math

pg.init()
initial_width, initial_height = 800, 500
screen = pg.display.set_mode((initial_width, initial_height), pg.RESIZABLE)
clock = pg.time.Clock()
pg.display.set_caption('Fighter Game')
fireball_image = pg.image.load("C:/Users/saira/OneDrive/Desktop/Python projects/Fighter game/wmremove-transformed.png").convert_alpha()
pg.display.set_icon(fireball_image)
fullscreen = False
ko_triggered = False
ko_y = -200

BG_COLOR = (30, 30, 30)
PLAYER1_COLOR = (255, 0, 0)
PLAYER2_COLOR = (0, 0, 255)
FIREBALL_COLOR = (255, 165, 0) # Orange
BLOCK_SHIELD_COLOR = (50, 50, 255, 150) 

# --- Global Groups ---
all_sprites = pg.sprite.Group()
fireballs = pg.sprite.Group()

class Fireball(pg.sprite.Sprite):
    def __init__(self, start_x, start_y, direction, color, screen_width):
        super().__init__()
        self.direction = direction  # left or right
        self.speed = 500
        self.damage = 25
        self.screen_width = screen_width
        self.owner = None

        # Use image and scale
        self.original_image = fireball_image
        self.image = pg.transform.scale(self.original_image, (30, 30)) 
        if self.direction == "left":
            self.image = pg.transform.flip(self.image, True, False)
        self.rect = self.image.get_rect(center=(start_x, start_y))

    def update(self, dt, *args): # dt is the only argument for movement
        if self.direction == "right":
            self.rect.x += self.speed * dt
        else:
            self.rect.x -= self.speed * dt
        
        # Remove fireball if goes off screen
        if self.rect.right < 0 or self.rect.left > self.screen_width:
            self.kill()
# --- Player Class ---
class Player(pg.sprite.Sprite):
    def __init__(self, x_ratio, color, controls, typeofspecial):
        super().__init__()
        self.color = color
        self.x_ratio = x_ratio
        self.width_ratio = 0.06
        self.height_ratio = 0.2
        
        # Player attributes
        self.image = pg.Surface((50, 100))
        self.image.fill(color)
        self.rect = self.image.get_rect() 
        self.controls = controls
        self.speed = 300
        self.gravity = 0
        self.attacking = False
        self.blocking = False
        self.active_hitbox = None
        self.hit_opponents = []
        self.facing = "right" if x_ratio < 0.5 else "left" # Face
        self.health = 100
        self.max_health = 100
        
        self.typeofspecial = typeofspecial

        self.special_attack = 0
        self.max_special = 300 # Max special is 3
        self.special_cost = 100 # Cost to use one shot
        self.can_special = True 
        self.special_cooldown_timer = 0
        self.special_cooldown_time = 0.5 

        # Blocking Stamina Attributes
        self.block_stamina = 100
        self.max_block_stamina = 100
        self.block_drain_rate = 100 # Stamina drained per second while blocking
        self.block_recover_rate = 30 # Stamina recovered per second when not blocking
        
                # --- COMBO / STUN SYSTEM ---
        self.combo_count = 0
        self.last_hit_time = 0
        self.combo_reset_time = 0.8

        self.stunned = False
        self.stun_timer = 0
        self.knockback_velocity = 0

        self.last_attack_was_special = False

        self.max_jumps = 2
        self.jump_count = 0
        self.jump_pressed = False


    def initial_setup(self, screen_width, screen_height):
        # Calculate size based on screen dimensions
        w = int(screen_width * self.width_ratio)
        h = int(screen_height * self.height_ratio)
        floor = 0.8 * screen_height
        
        # Update image
        self.image = pg.Surface((w,h))
        self.image.fill(self.color)
        
        # Set initial position
        self.rect = self.image.get_rect(midbottom=(int(screen_width * self.x_ratio), floor))

    def update_rect(self, screen_width, screen_height):
        w = int(screen_width * self.width_ratio)
        h = int(screen_height * self.height_ratio)
        floor = 0.8 * screen_height
        
        # Store current position before resizing
        old_midbottom = self.rect.midbottom
        
        # Update image
        self.image = pg.Surface((w,h))
        self.image.fill(self.color)
        self.rect = self.image.get_rect(midbottom=old_midbottom)

        #floor
        if self.rect.bottom > floor:
            self.rect.bottom = floor
        
        #screen edges
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > screen_width:
            self.rect.right = screen_width
        
    def handle_input(self, dt, screen_height, screen_width):

        if ko_triggered or self.stunned:
            return
        keys = pg.key.get_pressed()
        floor = 0.8 * screen_height
        
        # Moving
        if keys[self.controls["left"]]:
            self.rect.x -= self.speed * dt
            self.facing = "left"
        if keys[self.controls["right"]]:
            self.rect.x += self.speed * dt
            self.facing = "right"
            
        JUMP_VELOCITY_RATIO = -0.036 
        JUMP_VELOCITY = screen_height * JUMP_VELOCITY_RATIO
        
        # --- JUMP (edge-triggered) ---
        if keys[self.controls["jump"]]:
            if not self.jump_pressed and self.jump_count < self.max_jumps:
                self.gravity = JUMP_VELOCITY
                self.jump_count += 1
                self.jump_pressed = True
        else:
            self.jump_pressed = False



        # Blocking 
        if keys[self.controls["block"]]:  
            if self.block_stamina > 0:
                self.blocking = True
            else:
                self.blocking = False 
        else:
            self.blocking = False
        
        if self.blocking:
            self.block_stamina -= self.block_drain_rate * dt
            if self.block_stamina < 0:
                self.block_stamina = 0
                self.blocking = False 
        else:
            self.block_stamina += self.block_recover_rate * dt
            if self.block_stamina > self.max_block_stamina:
                self.block_stamina = self.max_block_stamina
        
        # BasicAttack
        if keys[self.controls["attack"]]:
            if not self.attacking and not self.blocking:
                self.start_attack(screen_height)
        
        #Special Attack 
        if keys[self.controls["special"]] and self.special_attack >= self.special_cost and self.can_special and not self.attacking and not self.blocking:
            self.start_special(screen_width)

    def apply_gravity(self, screen_height):
        floor = 0.8 * screen_height
        
                # Knockback movement
        if self.knockback_velocity != 0:
            self.rect.x += self.knockback_velocity
            self.knockback_velocity *= 0.85
            if abs(self.knockback_velocity) < 1:
                self.knockback_velocity = 0

                # Stun timer
        if self.stunned:
            self.stun_timer -= 1 / 60
            if self.stun_timer <= 0:
                self.stunned = False

        GRAVITY_ACCELERATION_RATIO = 0.002
        GRAVITY_ACCELERATION = screen_height * GRAVITY_ACCELERATION_RATIO
        
        self.gravity += GRAVITY_ACCELERATION # Use scaled acceleration here
        self.rect.y += self.gravity
        if self.rect.bottom >= floor:
            self.rect.bottom = floor
            self.gravity = 0
            self.jump_count = 0

    def start_attack(self, screen_height):
        self.attacking = True
        self.attack_timer = 0.2
        w, h = self.rect.width, self.rect.height

        keys = pg.key.get_pressed()
        up_attack = keys[self.controls["jump"]]
        airborne = self.is_airborne(screen_height)

        # --- UP ATTACK ---
        if up_attack:
            if airborne:
                # UP AIR ATTACK
                self.active_hitbox = pg.Rect(
                    self.rect.centerx - 0.2*w,
                    self.rect.top - 0.5*h,
                    0.4*w,
                    0.5*h
                )
            else:
                # UP GROUND ATTACK
                self.active_hitbox = pg.Rect(
                    self.rect.centerx - 0.25*w,
                    self.rect.top - 0.4*h,
                    0.5*w,
                    0.4*h
                )

        # --- FORWARD ATTACK ---
        else:
            if self.facing == "right":
                self.active_hitbox = pg.Rect(
                    self.rect.right,
                    self.rect.top + 0.2*h,
                    0.35*w,
                    0.6*h
                )
            else:
                self.active_hitbox = pg.Rect(
                    self.rect.left - 0.35*w,
                    self.rect.top + 0.2*h,
                    0.35*w,
                    0.6*h
                )

        self.hit_opponents = []

    def start_special(self, screen_width):
        self.special_attack -= self.special_cost
        self.can_special = False
        self.special_cooldown_timer = self.special_cooldown_time
        self.last_attack_was_special = True
        #
        if self.typeofspecial == "fireball":
            # SpawnFireball
            start_x = self.rect.centerx
            start_y = self.rect.centery - 10 
            fireball = Fireball(start_x, start_y, self.facing, FIREBALL_COLOR, screen_width)
            fireball.owner = self # prevent self-damage
            all_sprites.add(fireball)
            fireballs.add(fireball)
        
        if self.typeofspecial == "dash":
            if self.facing == "right":
                self.rect.centerx += 300
            else:
                self.rect.centerx -= 300
        
        if self.typeofspecial == "heal":
            self.health += 20
            if self.health > self.max_health:
                self.health = self.max_health
        
        if self.typeofspecial == "shockwave":
            w, h = self.rect.width, self.rect.height
            shockwave_radius = max(w, h) * 1.85
            self.active_hitbox = pg.Rect(self.rect.centerx - shockwave_radius / 2,self.rect.centery - shockwave_radius / 2,shockwave_radius,shockwave_radius)
            self.attacking = True
            self.attack_timer = 0.3
            self.hit_opponents = []

    def update_attack(self, dt):
        # Basic Attack Timer
        if self.attacking:
            self.attack_timer -= dt
            if self.attack_timer <= 0:
                self.attacking = False
                self.active_hitbox = None
                self.hit_opponents = []
        
        # Special Cooldown Timer
        if not self.can_special:
            self.special_cooldown_timer -= dt
            if self.special_cooldown_timer <= 0:
                self.can_special = True
    
    def gain_special(self, amount):
        self.special_attack += amount
        if self.special_attack > self.max_special:
            self.special_attack = self.max_special

    def deal_damage(self, amount):
        self.health -= amount
        if self.health < 0:
            self.health = 0
        self.gain_special(amount * 0.5) 

    def update(self, dt, screen_width, screen_height):

        self.update_rect(screen_width, screen_height)
        self.handle_input(dt, screen_height, screen_width)
        self.apply_gravity(screen_height)
        self.update_attack(dt)
    
    def is_airborne(self, screen_height):
        floor = 0.8 * screen_height
        return self.rect.bottom < floor - 5

# --- Game Setup ---
player1 = Player(0.2, PLAYER1_COLOR, {"left": pg.K_a, 
                                      "right": pg.K_d, 
                                      "jump": pg.K_w,
                                      "attack": pg.K_e, 
                                      "special": pg.K_r, 
                                      "block": pg.K_t},"shockwave")
player2 = Player(0.8, PLAYER2_COLOR, {"left": pg.K_LEFT,
                                      "right": pg.K_RIGHT, 
                                      "jump": pg.K_UP,
                                      "attack": pg.K_KP1,
                                      "special": pg.K_KP2,
                                      "block": pg.K_KP3},"fireball")


player1.initial_setup(initial_width, initial_height)
player2.initial_setup(initial_width, initial_height)

players = pg.sprite.Group(player1, player2)
all_sprites.add(player1, player2)

def draw_block_shield(surface, player):
    if player.blocking:
        w, h = player.rect.width, player.rect.height
        
        shield_w = int(w * 2.1)
        shield_h = int(h * 1.3)
        
        shield_surface = pg.Surface((shield_w, shield_h), pg.SRCALPHA)
        
        # Define the rect for the ellipse, which will fill the shield_surface
        ellipse_rect = shield_surface.get_rect()
        
        # Draw the filled ellipse onto the transparent surface
        pg.draw.ellipse(shield_surface, BLOCK_SHIELD_COLOR, ellipse_rect)
        
        shield_rect = shield_surface.get_rect(center=player.rect.center)
        
        surface.blit(shield_surface, shield_rect)

def reset_game():
    global ko_triggered, ko_y

    ko_triggered = False
    ko_y = -200  

    player1.health = 100
    player2.health = 100

    player1.special_attack = 0
    player2.special_attack = 0

    player1.block_stamina = player1.max_block_stamina
    player2.block_stamina = player2.max_block_stamina

    player1.rect.midbottom = (int(width * player1.x_ratio), int(0.8 * height))
    player2.rect.midbottom = (int(width * player2.x_ratio), int(0.8 * height))

    player1.gravity = 0
    player2.gravity = 0

    player1.attacking = False
    player2.attacking = False

    player1.active_hitbox = None
    player2.active_hitbox = None

    player1.facing = "right"
    player2.facing = "left"


    player1.stunned = False
    player2.stunned = False
    player1.combo_count = 0
    player2.combo_count = 0
    player1.knockback_velocity = 0
    player2.knockback_velocity = 0


    for f in fireballs:
        f.kill()

def draw_bars(surface, width, height, player1, player2):
    bar_height = 0.05 * height
    segments = 10
    special_segments = 3 
    seg_width = width * 0.03
    
    #Health Bars
    for i in range(segments):
        # P1 Health
        color = PLAYER1_COLOR if player1.health >= (i+1)*10 else (100,0,0)
        pg.draw.rect(surface, color, (i*seg_width, 0, seg_width-2, bar_height))
        # P2 Health
        color = PLAYER2_COLOR if player2.health >= (i+1)*10 else (0,0,100)
        pg.draw.rect(surface, color, (width - (i+1)*seg_width, 0, seg_width-2, bar_height))

    #Special Bars
    special_bar_width = seg_width * special_segments
    bar_y_special = bar_height + 5

    # P1 Special Meter
    bar_x = 0
    pg.draw.rect(surface, (50,0,50), (bar_x, bar_y_special, special_bar_width, bar_height)) 
    filled_width = special_bar_width * (player1.special_attack / player1.max_special) 
    pg.draw.rect(surface, PLAYER1_COLOR, (bar_x, bar_y_special, filled_width, bar_height))
    # Draw separation lines 
    for j in range(1, special_segments): 
        line_x = bar_x + j * seg_width
        pg.draw.line(surface, (255, 255, 255), (line_x, bar_y_special), (line_x, bar_y_special + bar_height), 2)

    # P2 Special Meter
    bar_x = width - special_bar_width
    pg.draw.rect(surface, (50,0,50), (bar_x, bar_y_special, special_bar_width, bar_height)) 
    filled_width = special_bar_width * (player2.special_attack / player2.max_special) 
    pg.draw.rect(surface, PLAYER2_COLOR, (bar_x + special_bar_width - filled_width, bar_y_special, filled_width, bar_height)) 
    # Draw separation lines 
    for j in range(1, special_segments): 
        line_x = bar_x + j * seg_width
        pg.draw.line(surface, (255, 255, 255), (line_x, bar_y_special), (line_x, bar_y_special + bar_height), 2)

    #Block Stamina Bars
    block_bar_width = seg_width * 3 #bar size is 3 segments wide
    bar_y_block = bar_y_special + bar_height + 5
    block_color = (0, 200, 255) # blue for the bar
    block_bar_height = bar_height / 2

    #Block Stamina
    bar_x = 0
    pg.draw.rect(surface, (20, 20, 70), (bar_x, bar_y_block, block_bar_width, block_bar_height))
    filled_width = block_bar_width * (player1.block_stamina / player1.max_block_stamina)
    pg.draw.rect(surface, block_color, (bar_x, bar_y_block, filled_width, block_bar_height))

    # P2 Block Stamina
    bar_x = width - block_bar_width
    pg.draw.rect(surface, (20, 20, 70), (bar_x, bar_y_block, block_bar_width, block_bar_height))
    filled_width = block_bar_width * (player2.block_stamina / player2.max_block_stamina)
    # Draw from right to left
    pg.draw.rect(surface, block_color, (bar_x + block_bar_width - filled_width, bar_y_block, filled_width, block_bar_height))

# --- Main Loop ---
loop_variable = True
while loop_variable:
    # dt (delta time) is crucial for frame-rate independent movement and optimalisng the game
    dt = clock.tick(60) / 1000
    width, height = screen.get_size()

    for event in pg.event.get():
        if event.type == pg.QUIT:
            loop_variable = False
        if event.type == pg.KEYDOWN:
            if event.key == pg.K_f:
                fullscreen = not fullscreen
                if fullscreen:
                    screen = pg.display.set_mode((0, 0), pg.FULLSCREEN)
                else:
                    screen = pg.display.set_mode((800, 500), pg.RESIZABLE)
            if event.key == pg.K_ESCAPE:
                loop_variable = False
        if event.type == pg.VIDEORESIZE:    
            player1.update_rect(width, height)
            player2.update_rect(width, height)
    
    
    screen.fill(BG_COLOR)
    def handle_attack(attacker, defender, damage):
        now = pg.time.get_ticks() / 1000

        if attacker.active_hitbox and defender not in attacker.hit_opponents and attacker.active_hitbox.colliderect(defender.rect):

            # Combo reset if too slow
            if now - attacker.last_hit_time > attacker.combo_reset_time:
                attacker.combo_count = 0

            attacker.combo_count += 1
            attacker.last_hit_time = now
            attacker.hit_opponents.append(defender)

            if not defender.blocking:
                defender.deal_damage(damage)

            # Gain special
            attacker.gain_special(damage * 1.5)
            defender.gain_special(damage * 0.5)

            # --- 4 HIT COMBO EFFECT ---
            if attacker.combo_count >= 4:
                defender.stunned = True
                defender.stun_timer = 0.7
                defender.knockback_velocity = 18 if attacker.facing == "right" else -18
                attacker.combo_count = 0
            
            attacker.last_attack_was_special = False

    if not ko_triggered:
       
        players.update(dt, width, height) 
        # Update fireballs (handles movement)
        fireballs.update(dt) 

        # Players gain special meter passively
        player1.gain_special(10 * dt)
        player2.gain_special(10 * dt)

        # --- Collision Logic ---
        
        # Basic Attack vs Player
        handle_attack(player1, player2, 5)
        handle_attack(player2, player1, 5)

        # Fireball collisions
    for fireball in fireballs:
        if fireball.owner != player1 and fireball.rect.colliderect(player1.rect):

            attacker = fireball.owner
            defender = player1
            now = pg.time.get_ticks() / 1000

            # Combo timing
            if now - attacker.last_hit_time > attacker.combo_reset_time:
                attacker.combo_count = 0

            attacker.combo_count += 1
            attacker.last_hit_time = now

            if not defender.blocking:
                defender.deal_damage(fireball.damage)

            attacker.gain_special(fireball.damage * 1.5)
            defender.gain_special(fireball.damage * 0.5)

            # SPECIAL FINISHER KNOCKBACK
            if attacker.combo_count >= 4:
                defender.stunned = True
                defender.stun_timer = 0.9
                defender.knockback_velocity = 35 if attacker.facing == "right" else -35
                attacker.combo_count = 0

            fireball.kill()


        elif fireball.owner != player2 and fireball.rect.colliderect(player2.rect):

            attacker = fireball.owner
            defender = player2
            now = pg.time.get_ticks() / 1000

            if now - attacker.last_hit_time > attacker.combo_reset_time:
                attacker.combo_count = 0

            attacker.combo_count += 1
            attacker.last_hit_time = now

            if not defender.blocking:
                defender.deal_damage(fireball.damage)

            attacker.gain_special(fireball.damage * 1.5)
            defender.gain_special(fireball.damage * 0.5)

            if attacker.combo_count >= 4:
                defender.stunned = True
                defender.stun_timer = 0.9
                defender.knockback_velocity = 35 if attacker.facing == "right" else -35
                attacker.combo_count = 0

            fireball.kill()



    # --- Drawing ---
    
    # Draw players and active fireballs
    all_sprites.draw(screen) 

    # Draw the Block Shield for both players (NOW AN ELLIPSE)
    draw_block_shield(screen, player1)
    draw_block_shield(screen, player2)

    # Draw basic attack hitboxes 
    if player1.active_hitbox:
        pg.draw.rect(screen, PLAYER1_COLOR, player1.active_hitbox, 2)
    if player2.active_hitbox:
        pg.draw.rect(screen, PLAYER2_COLOR, player2.active_hitbox, 2)

    # Draw all status bars (Health, Special, Block Stamina)
    draw_bars(screen, width, height, player1, player2)


    # --- KO Animation ---
    if not ko_triggered and (player1.health <= 0 or player2.health <= 0):
        ko_triggered = True
        ko_y = -0.4 * height

    if ko_triggered:
        ko_y += 600 * dt
    if ko_y > 0.3 * height:
        ko_y = 0.3 * height

    if ko_triggered:
        try:
            ko_font = pg.font.Font("ARCADECLASSIC.ttf", int(0.25*height))
        except:
            ko_font = pg.font.SysFont("Arial", int(0.25*height), bold=True)

        winner_font = pg.font.SysFont("Arial", int(0.12*height), bold=True)
        ko_text_str = "KO"
        main_color = (255, 255, 255) 
        
        # Draw background splatter for effect
        for _ in range(15):
            offset_x = r.randint(-15,15)
            offset_y = r.randint(-5,5)
            splatter = ko_font.render(ko_text_str, True, (230,230,230))
            splatter_rect = splatter.get_rect(center=(width//2 + offset_x, int(ko_y) + offset_y))
            screen.blit(splatter, splatter_rect)

        # Draw main KO text
        ko_text = ko_font.render(ko_text_str, True, main_color)
        ko_rect = ko_text.get_rect(center=(width//2, int(ko_y)))
        screen.blit(ko_text, ko_rect)

        # Draw Winner text
        winner_text_str = "WINNER PLAYER 2" if player1.health <= 0 else "WINNER PLAYER 1"
        winner_color = PLAYER2_COLOR if player1.health <= 0 else PLAYER1_COLOR
        winner_text = winner_font.render(winner_text_str, True, winner_color)
        winner_rect = winner_text.get_rect(center=(width//2, int(ko_y + 0.15*height)))
        screen.blit(winner_text, winner_rect)

        # Draw replay button
        button_width = width * 0.25
        button_height = height * 0.1
        button_x = width//2 - button_width//2
        button_y = int(ko_y + 0.30 * height)

        replay_rect = pg.Rect(button_x, button_y, button_width, button_height)
        pg.draw.rect(screen, (200,200,200), replay_rect, border_radius=10)
        font = pg.font.SysFont("Arial", int(0.07 * height), bold=True)
        text = font.render("REPLAY", True, (255, 255, 255))
        text_rect = text.get_rect(center=replay_rect.center)
        screen.blit(text, text_rect)
        
        if ko_triggered and event.type == pg.MOUSEBUTTONDOWN:
            if replay_rect.collidepoint(event.pos):
                reset_game()
    

    pg.display.update()

pg.quit()
