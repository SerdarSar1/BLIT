import pygame as pg
import random as r
import math

pg.init()
initial_width, initial_height = 800, 500
screen = pg.display.set_mode((initial_width, initial_height), pg.RESIZABLE)
clock = pg.time.Clock()
pg.display.set_caption('Fighter Game')
fireball_image = pg.image.load("C:/Users/saira/OneDrive/Desktop/Python projects/Fighter game/wmremove-transformed.png").convert_alpha()
pg.display.set_icon(fireball_image)
fullscreen = False
ko_triggered = False
ko_y = -200

BG_COLOR = (30, 30, 30)
PLAYER1_COLOR = (255, 0, 0)
PLAYER2_COLOR = (0, 0, 255)
FIREBALL_COLOR = (255, 165, 0) # Orange
BLOCK_SHIELD_COLOR = (50, 50, 255, 150) 

# --- Global Groups ---
all_sprites = pg.sprite.Group()
fireballs = pg.sprite.Group()

class Fireball(pg.sprite.Sprite):
    def __init__(self, start_x, start_y, direction, color, screen_width):
        super().__init__()
        self.direction = direction  # left or right
        self.speed = 500
        self.damage = 25
        self.screen_width = screen_width
        self.owner = None

        self.original_image = fireball_image
        self.image = pg.transform.scale(self.original_image, (30, 30)) 
        if self.direction == "left":
            self.image = pg.transform.flip(self.image, True, False)
        self.rect = self.image.get_rect(center=(start_x, start_y))

    def update(self, dt, *args): 
        if self.direction == "right":
            self.rect.x += self.speed * dt
        else:
            self.rect.x -= self.speed * dt
        
        if self.rect.right < 0 or self.rect.left > self.screen_width:
            self.kill()

# --- Player Class ---
class Player(pg.sprite.Sprite):
    def __init__(self, x_ratio, color, controls, typeofspecial):
        super().__init__()
        self.color = color
        self.x_ratio = x_ratio
        self.width_ratio = 0.06
        self.height_ratio = 0.2
        
        self.image = pg.Surface((50, 100))
        self.image.fill(color)
        self.rect = self.image.get_rect() 
        self.controls = controls
        self.speed = 300
        self.gravity = 0
        self.attacking = False
        self.blocking = False
        self.active_hitbox = None
        self.hit_opponents = []
        self.facing = "right" if x_ratio < 0.5 else "left"
        self.health = 100
        self.max_health = 100
        
        self.typeofspecial = typeofspecial
        self.special_attack = 300
        self.max_special = 300
        self.special_cost = 100
        self.can_special = True 
        self.special_cooldown_timer = 0
        self.special_cooldown_time = 0.5 

        self.block_stamina = 100
        self.max_block_stamina = 100
        self.block_drain_rate = 100
        self.block_recover_rate = 30
        
        self.combo_count = 0
        self.last_hit_time = 0
        self.combo_reset_time = 0.8

        self.stunned = False
        self.stun_timer = 0
        self.knockback_velocity = 0
        
        self.shockwave_damage = 30
        self.shockwave_base_damage = 15
        self.shockwave_height_multiplier = 0.08

        self.attack_type = "normal"

        self.max_jumps = 2
        self.jump_count = 0
        self.jump_pressed = False

        # Dash state
        self.dashing = False
        self.dash_speed = 3000
        self.dash_time = 0.08
        self.dash_timer = 0
        self.dash_trail = []  
        self.dash_trail_max = 10  

        self.max_dash_charges = 3
        self.dash_charges = 0
        self.dash_hit_this_dash = False

        self.display_health = self.health
        
        if self.typeofspecial == "joker":
            self.joker_deck = ["fireball", "dash", "heal", "shockwave"]  # list
            r.shuffle(self.joker_deck)  # shuffle 
            self.joker_index = 0          # points to next
            self.joker_current = self.joker_deck[self.joker_index]
        else:
            self.joker_deck = None
            self.joker_index = None
            self.joker_current = None


    def initial_setup(self, screen_width, screen_height):
        w = int(screen_width * self.width_ratio)
        h = int(screen_height * self.height_ratio)
        floor = 0.8 * screen_height
        
        self.image = pg.Surface((w,h))
        self.image.fill(self.color)
        self.rect = self.image.get_rect(midbottom=(int(screen_width * self.x_ratio), floor))

    def update_rect(self, screen_width, screen_height):
        w = int(screen_width * self.width_ratio)
        h = int(screen_height * self.height_ratio)
        floor = 0.8 * screen_height
        old_midbottom = self.rect.midbottom
        
        self.image = pg.Surface((w,h))
        self.image.fill(self.color)
        self.rect = self.image.get_rect(midbottom=old_midbottom)

        if self.rect.bottom > floor:
            self.rect.bottom = floor
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > screen_width:
            self.rect.right = screen_width

    def handle_input(self, dt, screen_height, screen_width):
        if ko_triggered or self.stunned:
            return
        keys = pg.key.get_pressed()
        floor = 0.8 * screen_height
        
        if not self.dashing:
            if keys[self.controls["left"]]:
                self.rect.x -= self.speed * dt
                self.facing = "left"
            if keys[self.controls["right"]]:
                self.rect.x += self.speed * dt
                self.facing = "right"
        
       
        JUMP_VELOCITY_RATIO = -0.036 
        JUMP_VELOCITY = screen_height * JUMP_VELOCITY_RATIO
        
        wall_touch = None
        if self.rect.left <= 0:
            wall_touch = "left"
        elif self.rect.right >= screen_width:
            wall_touch = "right"

        # Jumping + wall jump
        if keys[self.controls["jump"]]:
            if not self.jump_pressed:
                if self.jump_count < self.max_jumps:
                    self.gravity = JUMP_VELOCITY
                    self.jump_count += 1
                elif wall_touch:
                    self.gravity = JUMP_VELOCITY
                    if wall_touch == "left":
                        self.rect.x += int(0.1 * screen_width)
                        self.facing = "right"
                    else:
                        self.rect.x -= int(0.1 * screen_width)
                        self.facing = "left"
                self.jump_pressed = True
        else:
            self.jump_pressed = False

        # Blocking 
        if keys[self.controls["block"]]:  
            self.blocking = self.block_stamina > 0
        else:
            self.blocking = False

        if self.blocking:
            self.block_stamina -= self.block_drain_rate * dt
            if self.block_stamina < 0:
                self.block_stamina = 0
                self.blocking = False
        else:
            self.block_stamina += self.block_recover_rate * dt
            if self.block_stamina > self.max_block_stamina:
                self.block_stamina = self.max_block_stamina

        # BasicAttack
        if keys[self.controls["attack"]] and not self.attacking and not self.blocking:
            self.start_attack(screen_height)
        
        if (keys[self.controls["special"]] and
            self.special_attack >= self.special_cost and
            self.can_special and not self.attacking and not self.blocking):
            self.start_special(screen_width)

    def apply_gravity(self, screen_height, screen_width=None):
        floor = 0.8 * screen_height
        GRAVITY_ACCELERATION_RATIO = 0.002
        GRAVITY_ACCELERATION = screen_height * GRAVITY_ACCELERATION_RATIO
        WALL_SLIDE_SPEED_RATIO = 0.5

        # Wall slide
        wall_touch = self.is_touching_wall(screen_width) if screen_width else None
        if wall_touch and self.is_airborne(screen_height):
            self.gravity = min(self.gravity, GRAVITY_ACCELERATION / WALL_SLIDE_SPEED_RATIO)

        # Apply gravity
        self.gravity += GRAVITY_ACCELERATION
        self.rect.y += self.gravity

        # Floor collision
        if self.rect.bottom >= floor:
            self.rect.bottom = floor
            self.gravity = 0
            self.jump_count = 0

        # Knockback movement
        if self.knockback_velocity != 0:
            self.rect.x += self.knockback_velocity
            self.knockback_velocity *= 0.85
            if abs(self.knockback_velocity) < 1:
                self.knockback_velocity = 0

        # Stun timer
        if self.stunned:
            self.stun_timer -= 1 / 60
            if self.stun_timer <= 0:
                self.stunned = False

    def start_attack(self, screen_height):
        self.attack_type = "normal"
        self.attacking = True
        self.attack_timer = 0.2
        w, h = self.rect.width, self.rect.height
        keys = pg.key.get_pressed()
        up_attack = keys[self.controls["jump"]]
        airborne = self.is_airborne(screen_height)

        if up_attack:
            if airborne:
                self.active_hitbox = pg.Rect(self.rect.centerx - 0.2*w, self.rect.top - 0.5*h, 0.4*w, 0.5*h)
            else:
                self.active_hitbox = pg.Rect(self.rect.centerx - 0.25*w, self.rect.top - 0.4*h, 0.5*w, 0.4*h)
        else:
            if self.facing == "right":
                self.active_hitbox = pg.Rect(self.rect.right, self.rect.top + 0.2*h, 0.35*w, 0.6*h)
            else:
                self.active_hitbox = pg.Rect(self.rect.left - 0.35*w, self.rect.top + 0.2*h, 0.35*w, 0.6*h)
        self.hit_opponents = []

    def start_special(self, screen_width):
        self.special_attack -= self.special_cost
        self.can_special = False
        self.special_cooldown_timer = self.special_cooldown_time
        self.last_attack_was_special = True

        if self.typeofspecial == "joker":
            chosen = self.joker_current
        else:
            chosen = self.typeofspecial

        if chosen == "fireball":
            self.attack_type = "fireball"
            start_x = self.rect.centerx
            start_y = self.rect.centery - 10 
            fireball = Fireball(start_x, start_y, self.facing, FIREBALL_COLOR, screen_width)
            fireball.owner = self
            all_sprites.add(fireball)
            fireballs.add(fireball)

        if chosen == "dash":
            self.attack_type = "dash"
            self.dashing = True
            self.dash_timer = self.dash_time
            self.dash_charges = self.max_dash_charges
            self.dash_hit_this_dash = False
            self.hit_opponents =[]

        if chosen == "heal":
            self.health += 20
            if self.health > self.max_health:
                self.health = self.max_health

        if chosen == "shockwave":
            self.attack_type = "shockwave"
            w, h = self.rect.width, self.rect.height
            shockwave_radius = max(w, h) * 1.85
            self.active_hitbox = pg.Rect(self.rect.centerx - shockwave_radius/2, self.rect.centery - shockwave_radius/2, shockwave_radius, shockwave_radius)
            self.attacking = True
            self.attack_timer = 0.3
            self.hit_opponents = []
        
        if self.typeofspecial == "joker":
            self.joker_index += 1
            if self.joker_index >= len(self.joker_deck):
                self.joker_index = 0  # looping
            self.joker_current = self.joker_deck[self.joker_index]
    
    def update_attack(self, dt):
        if self.attacking:
            self.attack_timer -= dt
            if self.attack_timer <= 0:
                self.attacking = False
                self.active_hitbox = None
                self.hit_opponents = []
        if not self.can_special:
            self.special_cooldown_timer -= dt
            if self.special_cooldown_timer <= 0:
                self.can_special = True

    def gain_special(self, amount):
        self.special_attack += amount
        if self.special_attack > self.max_special:
            self.special_attack = self.max_special

    def deal_damage(self, amount):
        self.health -= amount
        if self.health < 0:
            self.health = 0
        self.gain_special(amount * 0.5) 

    def update(self, dt, screen_width, screen_height):
        self.update_rect(screen_width, screen_height)
        self.handle_input(dt, screen_height, screen_width)
        
        if self.dashing:
            direction = 1 if self.facing == "right" else -1
            self.rect.x += direction * self.dash_speed * dt
            self.dash_timer -= dt

            self.active_hitbox = pg.Rect(
                min(self.rect.centerx, self.rect.centerx + direction * self.dash_speed * dt),
                self.rect.top,
                self.rect.width * 0.6 + self.dash_speed * dt,
                self.rect.height
            )

            # Dash trail effect
            trail_surf = self.image.copy()
            trail_surf.fill((255,255,255), special_flags=pg.BLEND_RGB_ADD)
            trail_rect = trail_surf.get_rect(center=self.rect.center)
            self.dash_trail.append([trail_surf, trail_rect, 180])

            if len(self.dash_trail) > self.dash_trail_max:
                self.dash_trail.pop(0)

            if self.dash_timer <= 0:
                self.dashing = False
                self.active_hitbox = None
                self.dash_hit_this_dash = False
                self.hit_opponents = []

        if not self.dashing and self.attack_type == "dash":
            self.attack_type = "normal"


        self.apply_gravity(screen_height, screen_width)
        self.update_attack(dt)
        self.display_health += (self.health - self.display_health) * 0.12

        for trail in self.dash_trail:
            trail[2] -= 600 * dt  # fade speed
        self.dash_trail = [t for t in self.dash_trail if t[2] > 0]  # remove invisible

        # Draw trail
        for trail_surf, trail_rect, alpha in self.dash_trail:
            surf = trail_surf.copy()
            surf.set_alpha(int(alpha))
            screen.blit(surf, trail_rect)

    def is_airborne(self, screen_height):
        floor = 0.8 * screen_height
        return self.rect.bottom < floor - 5
    
    def is_touching_wall(self, screen_width):
        if self.rect.left <= 0:
            return "left"
        elif self.rect.right >= screen_width:
            return "right"
        return None

# --- Game Setup ---
player1 = Player(0.2, PLAYER1_COLOR, {"left": pg.K_a, "right": pg.K_d, "jump": pg.K_w, "attack": pg.K_e, "special": pg.K_r, "block": pg.K_t}, "heal")
player2 = Player(0.8, PLAYER2_COLOR, {"left": pg.K_LEFT, "right": pg.K_RIGHT, "jump": pg.K_UP, "attack": pg.K_KP1, "special": pg.K_KP2, "block": pg.K_KP3}, "joker")

player1.initial_setup(initial_width, initial_height)
player2.initial_setup(initial_width, initial_height)
players = pg.sprite.Group(player1, player2)
all_sprites.add(player1, player2)

def draw_block_shield(surface, player):
    if player.blocking:
        w, h = player.rect.width, player.rect.height
        
        shield_w = int(w * 2.1)
        shield_h = int(h * 1.3)
        
        shield_surface = pg.Surface((shield_w, shield_h), pg.SRCALPHA)
        
        ellipse_rect = shield_surface.get_rect()
        
        pg.draw.ellipse(shield_surface, BLOCK_SHIELD_COLOR, ellipse_rect)
        
        shield_rect = shield_surface.get_rect(center=player.rect.center)
        
        surface.blit(shield_surface, shield_rect)

def reset_game():
    global ko_triggered, ko_y

    ko_triggered = False
    ko_y = -200  

    player1.health = 100
    player2.health = 100

    player1.special_attack = 0
    player2.special_attack = 0

    player1.block_stamina = player1.max_block_stamina
    player2.block_stamina = player2.max_block_stamina

    player1.rect.midbottom = (int(width * player1.x_ratio), int(0.8 * height))
    player2.rect.midbottom = (int(width * player2.x_ratio), int(0.8 * height))

    player1.gravity = 0
    player2.gravity = 0

    player1.attacking = False
    player2.attacking = False

    player1.active_hitbox = None
    player2.active_hitbox = None

    player1.facing = "right"
    player2.facing = "left"


    player1.stunned = False
    player2.stunned = False
    player1.combo_count = 0
    player2.combo_count = 0
    player1.knockback_velocity = 0
    player2.knockback_velocity = 0


    for f in fireballs:
        f.kill()

def draw_bars(surface, width, height, player1, player2):
    bar_height = 0.05 * height
    seg_width = width * 0.03
    special_segments = 3
    block_bar_height = bar_height / 2
    spacing = 5

    pg.draw.rect(surface, (60, 60, 60), (0, 0, width * 0.35, bar_height))
    pg.draw.rect(surface, (230, 230, 230), (0, 0, (width*0.35) * (player1.display_health/player1.max_health), bar_height))
    color_hp1 = PLAYER1_COLOR if player1.health/player1.max_health >= 0.3 else (255, 80, 80)
    pg.draw.rect(surface, color_hp1, (0, 0, (width*0.35) * (player1.health/player1.max_health), bar_height))

    bar_y_special = bar_height + spacing
    special_bar_width = seg_width * special_segments
    bar_x = 0
    pg.draw.rect(surface, (50,0,50), (bar_x, bar_y_special, special_bar_width, bar_height))
    filled_width = special_bar_width * (player1.special_attack/player1.max_special)
    pg.draw.rect(surface, PLAYER1_COLOR, (bar_x, bar_y_special, filled_width, bar_height))
    for j in range(1, special_segments):
        line_x = bar_x + j * seg_width
        pg.draw.line(surface, (255,255,255), (line_x, bar_y_special), (line_x, bar_y_special+bar_height), 2)

    bar_y_block = bar_y_special + bar_height + spacing
    block_bar_width = seg_width * 3
    bar_x = 0
    pg.draw.rect(surface, (20,20,70), (bar_x, bar_y_block, block_bar_width, block_bar_height))
    filled_width = block_bar_width * (player1.block_stamina/player1.max_block_stamina)
    pg.draw.rect(surface, (0,200,255), (bar_x, bar_y_block, filled_width, block_bar_height))

    bar_width_p2 = width * 0.35
    pg.draw.rect(surface, (60,60,60), (width - bar_width_p2, 0, bar_width_p2, bar_height))
    chip_width = bar_width_p2 * (player2.display_health/player2.max_health)
    pg.draw.rect(surface, (230,230,230), (width - bar_width_p2 + bar_width_p2 - chip_width, 0, chip_width, bar_height))
    real_width = bar_width_p2 * (player2.health/player2.max_health)
    color_hp2 = PLAYER2_COLOR if player2.health/player2.max_health >= 0.3 else (255,80,80)
    pg.draw.rect(surface, color_hp2, (width - bar_width_p2 + bar_width_p2 - real_width, 0, real_width, bar_height))

    bar_y_special = bar_height + spacing
    special_bar_width = seg_width * special_segments
    bar_x = width - special_bar_width
    pg.draw.rect(surface, (50,0,50), (bar_x, bar_y_special, special_bar_width, bar_height))
    filled_width = special_bar_width * (player2.special_attack/player2.max_special)
    pg.draw.rect(surface, PLAYER2_COLOR, (bar_x + special_bar_width - filled_width, bar_y_special, filled_width, bar_height))
    for j in range(1, special_segments):
        line_x = bar_x + j * seg_width
        pg.draw.line(surface, (255,255,255), (line_x, bar_y_special), (line_x, bar_y_special+bar_height), 2)

    bar_y_block = bar_y_special + bar_height + spacing
    block_bar_width = seg_width * 3
    bar_x = width - block_bar_width
    pg.draw.rect(surface, (20,20,70), (bar_x, bar_y_block, block_bar_width, block_bar_height))
    filled_width = block_bar_width * (player2.block_stamina/player2.max_block_stamina)
    pg.draw.rect(surface, (0,200,255), (bar_x + block_bar_width - filled_width, bar_y_block, filled_width, block_bar_height))

loop_variable = True
while loop_variable:
    dt = clock.tick(60) / 1000
    width, height = screen.get_size()

    for event in pg.event.get():
        if event.type == pg.QUIT:
            loop_variable = False
        if event.type == pg.KEYDOWN:
            if event.key == pg.K_f:
                fullscreen = not fullscreen
                if fullscreen:
                    screen = pg.display.set_mode((0, 0), pg.FULLSCREEN)
                else:
                    screen = pg.display.set_mode((800, 500), pg.RESIZABLE)
            if event.key == pg.K_ESCAPE:
                loop_variable = False
        if event.type == pg.VIDEORESIZE:    
            player1.update_rect(width, height)
            player2.update_rect(width, height)
    
    
    screen.fill(BG_COLOR)
    def handle_attack(attacker, defender):
        now = pg.time.get_ticks() / 1000

        if attacker.attack_type == "dash" and attacker.dashing and attacker.active_hitbox:
            if attacker.active_hitbox.colliderect(defender.rect) and defender not in attacker.hit_opponents:
                defender.deal_damage(30)
                defender.stunned = True
                defender.stun_timer = 0.4
                defender.knockback_velocity = 15 if attacker.facing == "right" else -15

                attacker.hit_opponents.append(defender)
                attacker.dash_hit_this_dash = True
            return  

        if attacker.active_hitbox and attacker.active_hitbox.colliderect(defender.rect) and defender not in attacker.hit_opponents:

            # Combo reset
            if now - attacker.last_hit_time > attacker.combo_reset_time:
                attacker.combo_count = 0

            attacker.combo_count += 1
            attacker.last_hit_time = now
            attacker.hit_opponents.append(defender)

            damage = 5 

            # damage based on height
            if attacker.attack_type == "shockwave":
                floor = 0.8 * height
                height_above_ground = max(0, floor - attacker.rect.bottom)
                damage = attacker.shockwave_base_damage + height_above_ground * attacker.shockwave_height_multiplier

            # Apply damage if not blocking
            if not defender.blocking:
                defender.deal_damage(damage)

            # Special gain
            attacker.gain_special(damage * 1.5)
            defender.gain_special(damage * 0.5)

            # Stun on combo
            if attacker.combo_count >= 4:
                defender.stunned = True
                defender.stun_timer = 0.7
                defender.knockback_velocity = 18 if attacker.facing == "right" else -18
                attacker.combo_count = 0

    if not ko_triggered:
       
        players.update(dt, width, height) 
        # Update fireballs 
        fireballs.update(dt) 

        player1.gain_special(10 * dt)
        player2.gain_special(10 * dt)
        
        # Basic Attack 
        handle_attack(player1, player2)
        handle_attack(player2, player1)

        # Fireball collisions
    for fireball in fireballs:
        if fireball.owner != player1 and fireball.rect.colliderect(player1.rect):

            attacker = fireball.owner
            defender = player1
            now = pg.time.get_ticks() / 1000

            # Combo timing
            if now - attacker.last_hit_time > attacker.combo_reset_time:
                attacker.combo_count = 0

            attacker.combo_count += 1
            attacker.last_hit_time = now

            if not defender.blocking:
                defender.deal_damage(fireball.damage)

            attacker.gain_special(fireball.damage * 1.5)
            defender.gain_special(fireball.damage * 0.5)

            # SPECIAL FINISHER KNOCKBACK
            if attacker.combo_count >= 4:
                defender.stunned = True
                defender.stun_timer = 0.9
                defender.knockback_velocity = 35 if attacker.facing == "right" else -35
                attacker.combo_count = 0

            fireball.kill()


        elif fireball.owner != player2 and fireball.rect.colliderect(player2.rect):

            attacker = fireball.owner
            defender = player2
            now = pg.time.get_ticks() / 1000

            if now - attacker.last_hit_time > attacker.combo_reset_time:
                attacker.combo_count = 0

            attacker.combo_count += 1
            attacker.last_hit_time = now

            if not defender.blocking:
                defender.deal_damage(fireball.damage)

            attacker.gain_special(fireball.damage * 1.5)
            defender.gain_special(fireball.damage * 0.5)

            if attacker.combo_count >= 4:
                defender.stunned = True
                defender.stun_timer = 0.9
                defender.knockback_velocity = 35 if attacker.facing == "right" else -35
                attacker.combo_count = 0

            fireball.kill()

    all_sprites.draw(screen) 

    draw_block_shield(screen, player1)
    draw_block_shield(screen, player2)

    if player1.active_hitbox:
        pg.draw.rect(screen, PLAYER1_COLOR, player1.active_hitbox, 2)
    if player2.active_hitbox:
        pg.draw.rect(screen, PLAYER2_COLOR, player2.active_hitbox, 2)

    draw_bars(screen, width, height, player1, player2)

    #KO
    if not ko_triggered and (player1.health <= 0 or player2.health <= 0):
        ko_triggered = True
        ko_y = -0.4 * height

    if ko_triggered:
        ko_y += 600 * dt
    if ko_y > 0.3 * height:
        ko_y = 0.3 * height

    if ko_triggered:
        try:
            ko_font = pg.font.Font("ARCADECLASSIC.ttf", int(0.25*height))
        except:
            ko_font = pg.font.SysFont("Arial", int(0.25*height), bold=True)

        winner_font = pg.font.SysFont("Arial", int(0.12*height), bold=True)
        ko_text_str = "KO"
        main_color = (255, 255, 255) 
        
        # Draw background splatter for effect
        for _ in range(15):
            offset_x = r.randint(-15,15)
            offset_y = r.randint(-5,5)
            splatter = ko_font.render(ko_text_str, True, (230,230,230))
            splatter_rect = splatter.get_rect(center=(width//2 + offset_x, int(ko_y) + offset_y))
            screen.blit(splatter, splatter_rect)

        # Draw main KO text
        ko_text = ko_font.render(ko_text_str, True, main_color)
        ko_rect = ko_text.get_rect(center=(width//2, int(ko_y)))
        screen.blit(ko_text, ko_rect)

        # Draw Winner text
        winner_text_str = "WINNER PLAYER 2" if player1.health <= 0 else "WINNER PLAYER 1"
        winner_color = PLAYER2_COLOR if player1.health <= 0 else PLAYER1_COLOR
        winner_text = winner_font.render(winner_text_str, True, winner_color)
        winner_rect = winner_text.get_rect(center=(width//2, int(ko_y + 0.15*height)))
        screen.blit(winner_text, winner_rect)

        # Draw replay button
        button_width = width * 0.25
        button_height = height * 0.1
        button_x = width//2 - button_width//2
        button_y = int(ko_y + 0.30 * height)

        replay_rect = pg.Rect(button_x, button_y, button_width, button_height)
        pg.draw.rect(screen, (200,200,200), replay_rect, border_radius=10)
        font = pg.font.SysFont("Arial", int(0.07 * height), bold=True)
        text = font.render("REPLAY", True, (255, 255, 255))
        text_rect = text.get_rect(center=replay_rect.center)
        screen.blit(text, text_rect)
        
        if ko_triggered and event.type == pg.MOUSEBUTTONDOWN:
            if replay_rect.collidepoint(event.pos):
                reset_game()
    

    pg.display.update()

pg.quit()
